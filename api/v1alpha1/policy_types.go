package v1alpha1

import (
	"errors"
	"fmt"

	"github.com/aws/aws-sdk-go/aws/arn"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// NewPolicy constructs a Policy, setting mandatory fields for us
func NewPolicy(name, ns string, stm []StatementSpec) *Policy {
	return &Policy{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "irsa.voodoo.io/v1alpha1",
			Kind:       "Policy",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      name,
			Namespace: ns,
		},
		Spec: PolicySpec{
			Statement: stm,
		},
	}
}

func (p Policy) FullName() string {
	return p.ObjectMeta.Namespace + "/" + p.ObjectMeta.Name
}

// HasStatus is used in tests, should be moved there
func (p Policy) HasStatus(st fmt.Stringer) bool {
	return p.Status.Condition.String() == st.String()
}

// IsPendingDeletion helps us to detect if a Policy should be deleted
func (p Policy) IsPendingDeletion() bool {
	return !p.ObjectMeta.DeletionTimestamp.IsZero()
}

// PolicySpec describes the policy that must be present on AWS
type PolicySpec struct {
	ARN       string          `json:"arn,omitempty"` // the ARN of the aws policy
	Statement []StatementSpec `json:"statement"`
}

// Validate returns an error if the PolicySpec is not valid
func (spec PolicySpec) Validate() error {
	if len(spec.Statement) == 0 {
		return errors.New("empty Policy.spec.statement")
	}

	for i, stm := range spec.Statement {
		if err := stm.Validate(); err != nil {
			return fmt.Errorf("statement :%d : %s", i, err.Error())
		}
	}

	return nil
}

// StatementSpec defines an aws statement (Sid is autogenerated & Effect is always "allow")
type StatementSpec struct {
	Resource string   `json:"resource"` // ARN of the target aws resource
	Action   []string `json:"action"`   // the list of requested permissions on the aws resource above
}

// Validate returns an error if the StatementSpec is not valid
func (spec StatementSpec) Validate() error {
	if !arn.IsARN(spec.Resource) {
		return fmt.Errorf("%s is an invalid ARN", spec.Resource)
	}

	if len(spec.Action) == 0 {
		return errors.New("empty action array provided")
	}

	for i, a := range spec.Action {
		if a == "" {
			return fmt.Errorf("action #%d: empty action provided", i)
		}
	}

	return nil
}

// IsSame is used to detect meaningful difference between 2 StatementSpec
// ie : order of .Action elements is not taken into account
func (a StatementSpec) IsSame(b StatementSpec) bool {
	if a.Resource != b.Resource {
		return false
	}

	if len(a.Action) != len(b.Action) {
		return false
	}

	// we must ignore actions order
	for _, sA := range a.Action {
		diff := true
		for _, sB := range b.Action {
			if sA == sB {
				diff = false
				break
			}
		}
		if diff {
			return false
		}
	}
	return true
}

// StatementEquals is used to detect meaningful difference between 2 StatementSpec slices
// ie : order of elements is not taken into account
func StatementEquals(a, b []StatementSpec) bool {
	if len(a) != len(b) {
		return false
	}

	for _, sA := range a {
		diff := true
		for _, sB := range b {
			if sA.IsSame(sB) {
				diff = false
				break
			}
		}
		if diff {
			return false
		}
	}
	return true
}

// PolicyStatus defines the observed state of Policy
type PolicyStatus struct {
	Condition CrCondition `json:"condition"`
	Reason    string      `json:"reason,omitempty"`
}

func NewPolicyStatus(condition CrCondition, reason string) PolicyStatus {
	return PolicyStatus{
		Condition: condition,
		Reason:    reason,
	}
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// Policy is the Schema for the awspolicies API
type Policy struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   PolicySpec   `json:"spec,omitempty"`
	Status PolicyStatus `json:"status,omitempty"`
}

// Validate returns an error if the Policy is not valid
func (p Policy) Validate(cN string) error {
	if err := p.Spec.Validate(); err != nil {
		return err
	}

	awsName := p.AwsName(cN)
	if len(awsName) > 64 {
		return fmt.Errorf("genereated uniqueName ( `%s` ) is too long ", awsName)
	}

	return nil
}

// AwsName is the name the resource will have on AWS
// It must be unique per AWS account thus the naming convention
func (p Policy) AwsName(cN string) string {
	return fmt.Sprintf("irsa-op-%s-%s-%s", cN, p.ObjectMeta.Namespace, p.ObjectMeta.Name)
}

// PathPrefix is the "directory" where the policy will be available
// It's used to retrieved a policy on AWS
func (p Policy) PathPrefix(cN string) string {
	return fmt.Sprintf("/irsa-operator/%s/%s/%s/", cN, p.ObjectMeta.Namespace, p.ObjectMeta.Name)
}

// Path is the "file" where the policy will be available
func (p Policy) Path(cN string) string {
	return fmt.Sprintf("%spolicy/", p.PathPrefix(cN))
}

// +kubebuilder:object:root=true

// PolicyList contains a list of Policy
type PolicyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Policy `json:"items"`
}

func init() {
	SchemeBuilder.Register(&Policy{}, &PolicyList{})
}
